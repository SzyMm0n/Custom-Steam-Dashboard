from __future__ import annotations

import asyncio
from typing import Optional

from PySide6.QtCore import Qt
from PySide6.QtGui import QPixmap
from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QPushButton,
    QTableWidget,
    QTableWidgetItem,
    QHeaderView,
    QMessageBox,
)

from app.core.services.steam_api import SteamWebApiClient, PlayerSummary, SteamGame


class SteamUserInfoDialog(QDialog):
    """Dialog showing Steam user profile (name + avatar) and owned games table.

    Table columns: game name | total hours | last 2 weeks (h)
    """

    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Logowanie / Informacje o użytkowniku Steam")
        self.setMinimumSize(800, 560)
        self._init_ui()

    def _init_ui(self) -> None:
        layout = QVBoxLayout(self)

        # Profile row
        prof = QHBoxLayout()
        self.avatar_lbl = QLabel()
        self.avatar_lbl.setFixedSize(64, 64)
        self.avatar_lbl.setScaledContents(True)
        prof.addWidget(self.avatar_lbl)

        self.persona_lbl = QLabel("Nieznany użytkownik")
        f = self.persona_lbl.font()
        f.setPointSize(f.pointSize() + 2)
        f.setBold(True)
        self.persona_lbl.setFont(f)
        prof.addWidget(self.persona_lbl, 1)
        layout.addLayout(prof)

        # Inputs
        row1 = QHBoxLayout()
        row1.addWidget(QLabel("SteamID:"))
        self.steamid_input = QLineEdit()
        self.steamid_input.setPlaceholderText("Wpisz SteamID64 (np. 7656119...)")
        row1.addWidget(self.steamid_input, 1)
        layout.addLayout(row1)

        row2 = QHBoxLayout()
        row2.addWidget(QLabel("API Key (opcjonalnie):"))
        self.api_key_input = QLineEdit()
        self.api_key_input.setEchoMode(QLineEdit.EchoMode.Password)
        self.api_key_input.setPlaceholderText("Jeśli puste, użyje zmiennej STEAM_API_KEY")
        row2.addWidget(self.api_key_input, 1)
        layout.addLayout(row2)

        # Buttons
        btns = QHBoxLayout()
        self.fetch_btn = QPushButton("Pobierz dane")
        self.fetch_btn.clicked.connect(lambda: asyncio.create_task(self._on_fetch_clicked()))
        btns.addWidget(self.fetch_btn)
        btns.addStretch(1)
        close_btn = QPushButton("Zamknij")
        close_btn.clicked.connect(self.reject)
        btns.addWidget(close_btn)
        layout.addLayout(btns)

        # Status
        self.status_lbl = QLabel("")
        self.status_lbl.setWordWrap(True)
        layout.addWidget(self.status_lbl)

        # Table
        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels([
            "Nazwa gry",
            "Łączna liczba godzin",
            "Ostatnie 2 tyg. (h)",
        ])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.table.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.ResizeToContents)
        self.table.horizontalHeader().setSectionResizeMode(2, QHeaderView.ResizeMode.ResizeToContents)
        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.table.setAlternatingRowColors(True)
        layout.addWidget(self.table, 1)

        # Style
        self.setStyleSheet(
            """
            QDialog { background-color: #0b0b0b; color: #FFFFFF; }
            QLineEdit { background-color: #1b1b1b; color: #fff; border: 1px solid #2a2a2a; border-radius: 4px; padding: 4px; }
            QPushButton { background-color: #16a34a; color: #FFFFFF; border-radius: 6px; padding: 6px 10px; }
            QTableWidget { background-color: #111111; color: #FFFFFF; border: 1px solid #2a2a2a; }
            QHeaderView::section { background-color: #15331f; color: #fff; border: none; padding: 6px; }
            """
        )

    async def _on_fetch_clicked(self) -> None:
        steamid = self.steamid_input.text().strip()
        api_key = self.api_key_input.text().strip() or None
        if not steamid:
            QMessageBox.warning(self, "Brak SteamID", "Podaj prawidłowy SteamID64.")
            return
        self.fetch_btn.setEnabled(False)
        self.status_lbl.setText("Pobieranie danych profilu i biblioteki...")
        self.persona_lbl.setText("Ładowanie...")
        self.avatar_lbl.clear()
        self.table.setRowCount(0)

        try:
            summary, owned = await self._fetch_summary_and_owned(steamid, api_key)
        except Exception as e:
            self.status_lbl.setText(f"Błąd: {e}")
            self.fetch_btn.setEnabled(True)
            return

        # Profile
        if summary:
            self.persona_lbl.setText(summary.personaname or summary.steamid)
            url = summary.avatarfull or summary.avatarmedium or summary.avatar
            if url:
                try:
                    import httpx
                    async with httpx.AsyncClient(timeout=10.0) as client:
                        r = await client.get(url)
                        if r.status_code == 200:
                            pix = QPixmap()
                            pix.loadFromData(r.content)
                            self.avatar_lbl.setPixmap(pix)
                except Exception:
                    pass
        else:
            self.persona_lbl.setText("(brak danych profilu)")

        # Table
        owned_sorted = sorted(owned, key=lambda g: (g.playtime_forever or 0), reverse=True)
        self.table.setRowCount(len(owned_sorted))
        for row, g in enumerate(owned_sorted):
            name_item = QTableWidgetItem(g.name or f"AppID {g.appid}")
            total_h = (g.playtime_forever or 0) / 60.0
            last2w_h = (g.playtime_2weeks or 0) / 60.0
            total_item = QTableWidgetItem(f"{total_h:.1f}")
            last_item = QTableWidgetItem(f"{last2w_h:.1f}")
            total_item.setTextAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            last_item.setTextAlignment(Qt.AlignmentFlag.AlignRight | Qt.AlignmentFlag.AlignVCenter)
            self.table.setItem(row, 0, name_item)
            self.table.setItem(row, 1, total_item)
            self.table.setItem(row, 2, last_item)
        self.table.resizeColumnsToContents()

        self.status_lbl.setText(f"Załadowano gier: {len(owned_sorted)}")
        self.fetch_btn.setEnabled(True)

    async def _fetch_summary_and_owned(self, steamid: str, api_key: Optional[str]):
        async with SteamWebApiClient(api_key=api_key) as api:
            summary: Optional[PlayerSummary] = await api.get_player_summary(steamid)
            owned: list[SteamGame] = await api.get_owned_games(steamid)
        return summary, owned
