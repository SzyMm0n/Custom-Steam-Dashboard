from __future__ import annotations

import asyncio
import re
import xml.etree.ElementTree as ET
from abc import ABC, abstractmethod
from os import getenv
from typing import List, Optional, Tuple

import httpx
from pydantic import BaseModel, ConfigDict, Field

from common._base_http import BaseAsyncService

# === Pydantic models ===

class PlayerCount(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    appid: int
    player_count: int = 0


class NewsItem(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    gid: str
    title: str
    url: str
    author: Optional[str] = None
    contents: Optional[str] = None
    feedlabel: Optional[str] = Field(default=None, description="Feed label e.g. Steam Community Announcements")
    date: int = Field(description="Unix epoch seconds")
    is_update_like: bool = Field(default=False, description="Heuristic: whether this looks like an update/patch note")


class ReleaseInfo(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    coming_soon: bool = False
    date: Optional[str] = None


class PriceOverview(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    currency: Optional[str] = None
    initial: Optional[int] = None
    final: Optional[int] = None
    discount_percent: int = 0


class AppDetails(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    appid: int
    name: Optional[str] = None
    dlc: Optional[List[int]] = None
    genres: Optional[List[str]] = None
    categories: Optional[List[str]] = None
    release_date: Optional[ReleaseInfo] = None
    is_free: Optional[bool] = None
    price_overview: Optional[PriceOverview] = None


class FeaturedItem(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    id: int = Field(description="Steam appid")
    name: Optional[str] = None
    release_date: Optional[str] = None
    final_price: Optional[int] = None
    discount_percent: int = 0
    capsule_image: Optional[str] = None
    large_capsule_image: Optional[str] = None

class SteamGame(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    appid: int
    name: str
    playtime_forever: Optional[int] = Field(default=0, description="Total playtime in minutes")
    playtime_2weeks: Optional[int] = Field(default=0, description="Playtime in the last 2 weeks in minutes")

class TopGame(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    appid: int
    name: Optional[str] = None
    categories: Optional[List[str]] = None
    genres: Optional[List[str]] = None
    rank: Optional[int] = None

class PlayerSummary(BaseModel):
    model_config = ConfigDict(extra="ignore", frozen=True)

    steamid: str
    personaname: Optional[str] = None
    profileurl: Optional[str] = None
    avatar: Optional[str] = None
    avatarmedium: Optional[str] = None
    avatarfull: Optional[str] = None


# === Interface ===

class ISteamStore(ABC):
    @abstractmethod
    async def get_number_of_current_players(self, appid: int) -> PlayerCount: ...

    @abstractmethod
    async def get_recent_news(self, appid: int, count: int = 5, updates_only: bool = True) -> List[NewsItem]: ...

    @abstractmethod
    async def get_app_details(self, appid: int, cc: str = "pln", lang: str = "en") -> Optional[AppDetails]: ...

    @abstractmethod
    async def get_coming_soon(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]: ...

    @abstractmethod
    async def get_new_releases(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]: ...

    @abstractmethod
    async def get_top_sellers(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]: ...

    @abstractmethod
    async def get_most_played(self, limit: int = 150) -> List[TopGame]: ...

    @abstractmethod
    async def get_player_history(self, appid: int, *, source: str = "steamcharts") -> List[Tuple[int, int]]: ...


class ISteamWebApi(ABC):
    @abstractmethod
    async def get_owned_games(self, steamid: str) -> List[SteamGame]: ...

    @abstractmethod
    async def get_recently_played(self, steamid: str) -> List[SteamGame]: ...

    @abstractmethod
    async def get_badges(self, steamid: str) -> dict: ...

    @abstractmethod
    async def get_player_summary(self, steamid: str) -> Optional[PlayerSummary]: ...


# === Implementation ===

class SteamStoreClient(BaseAsyncService, ISteamStore):
    def __init__(self, *, timeout: httpx.Timeout | float | None = None):
        if timeout is not None:
            super().__init__(timeout=timeout)
        else:
            super().__init__()

    # --- API methods ---

    async def get_number_of_current_players(self, appid: int) -> PlayerCount:
        url = "https://api.steampowered.com/ISteamUserStats/GetNumberOfCurrentPlayers/v1/"
        data = await self._get_json(url, params={"appid": appid})
        resp = data.get("response", {})
        count = int(resp.get("player_count") or 0)
        return PlayerCount(appid=appid, player_count=count)

    async def get_recent_news(self, appid: int, count: int = 5, updates_only: bool = True) -> List[NewsItem]:
        url = "https://api.steampowered.com/ISteamNews/GetNewsForApp/v2/"
        data = await self._get_json(url, params={"appid": appid, "count": count})
        items_raw = (data or {}).get("appnews", {}).get("newsitems", [])
        items: List[NewsItem] = []
        for item in items_raw:
            title = item.get("title", "") or ""
            is_update_like = _looks_like_update(title, item.get("feedlabel"))
            if updates_only and not is_update_like:
                continue
            items.append(
                NewsItem(
                    gid=str(item.get("gid")),
                    title=title,
                    url=item.get("url", ""),
                    author=item.get("author"),
                    contents=item.get("contents"),
                    feedlabel=item.get("feedlabel"),
                    date=int(item.get("date") or 0),
                    is_update_like=is_update_like,
                )
            )
        return items

    async def get_app_details(self, appid: int, cc: str = "pln", lang: str = "en") -> Optional[AppDetails]:
        url = "https://store.steampowered.com/api/appdetails"
        data = await self._get_json(url, params={"appids": appid, "cc": cc, "l": lang})
        node = data.get(str(appid)) if isinstance(data, dict) else None
        if not node or not node.get("success"):
            return None
        d = node.get("data", {})
        release_block = d.get("release_date", {}) or {}
        price_block = d.get("price_overview", {}) or {}
        genres_raw = d.get("genres") or []
        categories_raw = d.get("categories") or []
        genres_list = [str(g.get("description")) for g in genres_raw if isinstance(g, dict) and g.get("description")]
        categories_list = [str(c.get("description")) for c in categories_raw if isinstance(c, dict) and c.get("description")]
        dlc_list = d.get("dlc") if isinstance(d.get("dlc"), list) else None
        return AppDetails(
            appid=appid,
            name=d.get("name"),
            dlc=dlc_list,
            genres=genres_list or None,
            categories=categories_list or None,
            release_date=ReleaseInfo(
                coming_soon=bool(release_block.get("coming_soon") or False),
                date=release_block.get("date"),
            ),
            is_free=bool(d.get("is_free") or False),
            price_overview=(
                PriceOverview(
                    currency=price_block.get("currency"),
                    initial=price_block.get("initial"),
                    final=price_block.get("final"),
                    discount_percent=int(price_block.get("discount_percent") or 0),
                )
                if price_block
                else None
            ),
        )

    async def _get_featured_category_items(self, key: str, *, cc: str, lang: str, limit: int) -> List[FeaturedItem]:
        url = "https://store.steampowered.com/api/featuredcategories/"
        data = await self._get_json(url, params={"cc": cc, "l": lang})
        # Some deployments may use keys like "top_sellers" or "topsellers"; try both gracefully
        cat = (data or {}).get(key) or (data or {}).get(key.replace("_", "")) or {}
        items_raw = cat.get("items", [])
        items: List[FeaturedItem] = []
        for item in items_raw[: max(0, limit)]:
            items.append(
                FeaturedItem(
                    id=int(item.get("id")),
                    name=item.get("name"),
                    release_date=item.get("release_date"),
                    final_price=item.get("final_price"),
                    discount_percent=int(item.get("discount_percent") or 0),
                    capsule_image=item.get("capsule_image"),
                    large_capsule_image=item.get("large_capsule_image"),
                )
            )
        return items

    async def get_coming_soon(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]:
        return await self._get_featured_category_items("coming_soon", cc=cc, lang=lang, limit=limit)

    async def get_new_releases(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]:
        return await self._get_featured_category_items("new_releases", cc=cc, lang=lang, limit=limit)

    async def get_top_sellers(self, cc: str = "pln", lang: str = "en", limit: int = 30) -> List[FeaturedItem]:
        return await self._get_featured_category_items("top_sellers", cc=cc, lang=lang, limit=limit)

    async def get_most_played(self, limit: int = 150) -> List[TopGame]:
        limit = max(0, limit)
        results: List[TopGame] = []

        async def _fetch_details(appid: int, sem: asyncio.Semaphore) -> Optional[AppDetails]:
            async with sem:
                try:
                    return await self.get_app_details(appid)
                except Exception:
                    return None

        # Główne źródło: SteamChartsService
        try:
            url = "https://api.steampowered.com/ISteamChartsService/GetMostPlayedGames/v1/"
            data = await self._get_json(url)
            ranks = (((data or {}).get("response", {}) or {}).get("ranks", []) or [])[:limit]
            app_ids = [int(r.get("appid")) for r in ranks if r.get("appid") is not None]

            sem = asyncio.Semaphore(16)  # ograniczenie współbieżności
            details = await asyncio.gather(*(_fetch_details(appid, sem) for appid in app_ids))
            details_map = {d.appid: d for d in details if isinstance(d, AppDetails)}

            for node in ranks:
                appid = int(node.get("appid"))
                rank = int(node["rank"]) if node.get("rank") is not None else None
                d = details_map.get(appid)
                results.append(
                    TopGame(
                        appid=appid,
                        name=(d.name if d else None),
                        categories=(d.categories if d else None),
                        genres=(d.genres if d else None),
                        rank=rank,
                    )
                )
        except Exception:
            results = []

        return results


    async def get_player_history(self, appid: int, *, source: str = "steamcharts") -> List[Tuple[int, int]]:
        """Fetch historical player samples for an app.

        Uses steamcharts graph-data.json only.

        Returns list of tuples (ts_unix, players) ordered ascending by timestamp.
        """
        samples: List[Tuple[int, int]] = []
        if source not in ("steamcharts", "auto"):
            return samples
        url = f"https://steamcharts.com/app/{appid}/graph-data.json"
        try:
            data = await self._get_json(url)
            if data:
                for node in data:
                    try:
                        ts_ms = int(node[0])
                        players = int(node[1])
                        samples.append((ts_ms // 1000, players))
                    except Exception:
                        continue
                samples.sort(key=lambda x: x[0])
        except Exception:
            pass
        return samples


class SteamWebApiClient(BaseAsyncService, ISteamWebApi):
    def __init__(self, *, api_key: Optional[str] = None, timeout: float | None = None):
        super().__init__(timeout=timeout) if timeout is not None else super().__init__()
        self._api_key = api_key or getenv("STEAM_API_KEY")

    def _parse_hours_to_minutes(self, s: Optional[str]) -> int:
        if not s:
            return 0
        # keep digits, comma and dot
        cleaned = re.sub(r"[^0-9,\.]", "", s)
        # normalize comma to dot
        cleaned = cleaned.replace(",", ".")
        try:
            hours = float(cleaned)
        except Exception:
            return 0
        return int(round(hours * 60))

    async def _get_owned_games_public(self, steamid: str) -> List[SteamGame]:
        url = f"https://steamcommunity.com/profiles/{steamid}/games?tab=all&l=polish&xml=1"
        async with httpx.AsyncClient(timeout=15.0) as client:
            resp = await client.get(url)
            resp.raise_for_status()
            root = ET.fromstring(resp.text)
            games_node = root.find("games")
            if games_node is None:
                return []
            games: List[SteamGame] = []
            for g in games_node.findall("game"):
                try:
                    appid = int((g.findtext("appID") or "0").strip())
                except Exception:
                    continue
                name = g.findtext("name") or f"AppID {appid}"
                hours_total = g.findtext("hoursOnRecord")
                hours_2w = g.findtext("hoursLast2Weeks")
                games.append(
                    SteamGame(
                        appid=appid,
                        name=name,
                        playtime_forever=self._parse_hours_to_minutes(hours_total),
                        playtime_2weeks=self._parse_hours_to_minutes(hours_2w),
                    )
                )
            return games

    async def _get_player_summary_public(self, steamid: str) -> Optional[PlayerSummary]:
        url = f"https://steamcommunity.com/profiles/{steamid}?xml=1&l=polish"
        async with httpx.AsyncClient(timeout=10.0) as client:
            resp = await client.get(url)
            if resp.status_code != 200:
                return None
            try:
                root = ET.fromstring(resp.text)
            except Exception:
                return None
            persona = root.findtext("steamID") or None
            avatarfull = root.findtext("avatarFull") or None
            profileurl = f"https://steamcommunity.com/profiles/{steamid}/"
            return PlayerSummary(steamid=steamid, personaname=persona, avatarfull=avatarfull, profileurl=profileurl)

    def _require_key(self) -> str:
        if not self._api_key:
            raise RuntimeError("STEAM_API_KEY is required. Pass api_key=... or set env STEAM_API_KEY.")
        return self._api_key

    async def get_owned_games(self, steamid: str) -> List[SteamGame]:
        if self._api_key:
            key = self._require_key()
            url = "https://api.steampowered.com/IPlayerService/GetOwnedGames/v1/"
            params = {
                "key": key,
                "steamid": steamid,
                "include_appinfo": True,
                "include_played_free_games": True,
                "format": "json",
            }
            data = await self._get_json(url, params=params)
            games = (data or {}).get("response", {}).get("games", [])
            return [SteamGame.model_validate(g) for g in games]
        # Fallback without key
        return await self._get_owned_games_public(steamid)

    async def get_recently_played(self, steamid: str) -> List[SteamGame]:
        if self._api_key:
            key = self._require_key()
            url = "https://api.steampowered.com/IPlayerService/GetRecentlyPlayedGames/v1/"
            params = {"key": key, "steamid": steamid, "format": "json"}
            data = await self._get_json(url, params=params)
            games = (data or {}).get("response", {}).get("games", [])
            return [SteamGame.model_validate(g) for g in games]
        # Fallback: derive from owned with non-zero last2weeks
        owned = await self._get_owned_games_public(steamid)
        return [g for g in owned if (g.playtime_2weeks or 0) > 0]

    async def get_badges(self, steamid: str) -> dict:
        key = self._require_key()
        url = "https://api.steampowered.com/IPlayerService/GetBadges/v1/"
        params = {"key": key, "steamid": steamid, "format": "json"}
        data = await self._get_json(url, params=params)
        return (data or {}).get("response", {})

    async def get_player_summary(self, steamid: str) -> Optional[PlayerSummary]:
        if self._api_key:
            key = self._require_key()
            url = "https://api.steampowered.com/ISteamUser/GetPlayerSummaries/v2/"
            params = {"key": key, "steamids": steamid, "format": "json"}
            data = await self._get_json(url, params=params)
            players = (data or {}).get("response", {}).get("players", [])
            if not players:
                return None
            return PlayerSummary.model_validate(players[0])
        # Fallback: public profile XML
        return await self._get_player_summary_public(steamid)

# --- helpers ---

_UPDATE_KEYWORDS = (
    "update",
    "patch",
    "hotfix",
    "changelog",
    "release notes",
    "build",
)


def _looks_like_update(title: Optional[str], feedlabel: Optional[str]) -> bool:
    t = (title or "").lower()
    if any(k in t for k in _UPDATE_KEYWORDS):
        return True
    fl = (feedlabel or "").lower()
    if "announcements" in fl or "updates" in fl:
        return True
    return False


if __name__ == "__main__":
    # Async demo mirroring steam_store style; uses env STEAM_API_KEY and STEAM_ID
    import asyncio
    from dotenv import load_dotenv

    load_dotenv()

    async def demo() -> None:
        steamid = getenv("STEAM_ID")
        async with SteamWebApiClient() as api:
            owned = await api.get_owned_games(steamid)
            print(f"Owned games: {len(owned)} (showing up to 10):", [g.name for g in owned[:10]])

            recent = await api.get_recently_played(steamid)
            print(f"Recently played: {len(recent)} (showing up to 10):", [g.name for g in recent[:10]])

            summary = await api.get_player_summary(steamid)
            print("Player:", summary.personaname if summary else None)

        appid = 570  # Dota 2 as example
        async with SteamStoreClient() as client:
            players = await client.get_number_of_current_players(appid)
            print("Players:", players)

            news = await client.get_recent_news(appid, count=10, updates_only=True)
            print(f"News ({len(news)}):", [n.title for n in news[:3]])

            details = await client.get_app_details(appid)
            print("Details:", details)

            coming = await client.get_coming_soon(limit=5)
            print("Coming soon sample:", [i.name for i in coming])

            newr = await client.get_new_releases(limit=5)
            print("New releases sample:", [i.name for i in newr])

            most = await client.get_most_played()
            print("Most played sample:", [(g.rank, g.appid, g.name, g.categories, g.genres) for g in most])
    asyncio.run(demo())
